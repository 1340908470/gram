# 程序设计说明
> 姓名：陈威豪 
> 学号：2019211232 
> 班级：2019211303

## 手工计算例题

### 原表达式

```txt
E → E+T | E–T | T
T → T*F | T/F | F
F → (E) | num
```

### 消除左递归

```txt
E → TE'
E' → +TE' | -TE' | ε
T → FT'
T' → *FT' | /FT' | ε
F → (E) | num
```

### 原表达式FIRST集

```txt
E: ( num 
F: ( num 
T: ( num 
```

### 原表达式FOLLOW集

```txt
E: $ + - ) 
F: $ ) + - * / 
T: $ ) + - * / 
```

### 消除左递归FIRST集

```txt
E: ( num 
F: ( num 
T: ( num 
E': + - ε 
T': * / ε 
```

### 消除左递归FOLLOW集

```txt
E: $ ) 
F: * / + - $ ) 
T: + - $ ) 
E': $ ) 
T': + - $ ) 
```

### 求LL分析表

```txt
+----+----------+----------+----------+----------+--------+-------+--------+-------+
|    |    +     |    -     |    *     |    /     |   (    |   )   |  num   |   $   |
+----+----------+----------+----------+----------+--------+-------+--------+-------+
| E' | E'->+TE' | E'->-TE' |          |          |        | E'->ε |        | E'->ε |
| E  |          |          |          |          | E->TE' |       | E->TE' |       |
| F  |          |          |          |          | F->(E) |       | F->num |       |
| T' |  T'->ε   |  T'->ε   | T'->*FT' | T'->/FT' |        | T'->ε |        | T'->ε |
| T  |          |          |          |          | T->FT' |       | T->FT' |       |
+----+----------+----------+----------+----------+--------+-------+--------+-------+
```

## 基本算法及思路

### 求解FIRST集

对于目标非终结符，查找所有以它为左部的产生式，可能有以下两种情况：

1. 产生式右部以终结符开始
2. 产生式右部以非终结符开始

对于第一种情况，终结符可以直接放到`FIRST`集中，对于第二种情况，则递归查询非终结符的`FIRST`集；

### 求解FOLLOW集

首先，对于递归查询函数，如果查询符号为开始符号，则将`$`符加到`FOLLOW`集中；

然后遍历查找右部中包含目标符号的产生式，可能出现以下几种情况：

1. 查询符号在产生式中间（即不在最后）
   1. 符号之后的其他符号中，存在`First`集不包括空的非终结符，或者终结符
   2. 符号之后的其他符号中，所有符号的`First`集中都包含空
2. 查询符号在产生式末尾

对于1.1，直接将之后的终结符，或者非终结符的`FIEST`集，加到查询符号的`FOLLOW`集中；

对于另外的情况，则将左部的`FOLLOW`集加到查询符号的`FOLLOW`集中；

## 基本struct及func定义

### base pkg

#### 标识符Tag
```go
type Tag struct {
	// 类型
	Type 	int
	// 值
	Value 	string		
}
```

#### 产生式Production
```go
type Production struct {
	// 当且仅当 Left.Type == NONTERM
	Left Tag
	// 产生式的右部是一个标识符切片
	Right []Tag		
}

// GetProductionsByTag 根据记号，返回该非终结符的所有产生式
func GetProductionsByTag(productions []Production, left Tag) ([]Production, error) {}

// ToString 将产生式转换成字符串
func (p Production) ToString() string {}
```

#### 消除左递归

直接将消除左递归后的产生式集放入堆空间中，替换未消除左递归的产生式集。

```go
// RemoveLeftRecursion 消除左递归
func RemoveLeftRecursion() {}
```

#### 构造拓广文法

调用函数后，会更新存放在栈空间中的全局变量`productions`和`prodMap`

```go
// GenerateExtension 构造拓广文法
func GenerateExtension() {}
```

#### 检测是否有重复的tag

```go
// HasReTags 是否有重复的tag
func HasReTags(tag Tag, tags []Tag) bool {
```

#### 生成FIRST集
传入一个非终结符，计算该非终结符的`First`集，`getFirstRE`是递归运算函数，处于`GetFirst`下层，不被其他程序调用
```go
// GetFirst 根据推导式的左部，得到其对应的FIRST集
func GetFirst(left Tag) []Tag {}

// GetFirstRE 递归查找First集，并将该次调用得到的tag加到ansTags中
func getFirstRE(symbol Tag, tmpTags []Tag, ansTags *[]Tag) {}
```

#### 生成FOLLOW集
传入一个非终结符，计算该非终结符的`FOLLOW`集，`getFollowRE`是递归运算函数，处于`GetFollow`下层，不被其他程序调用
```go
// GetFollow 根据推导式的左部，得到其对应的Follow集
func GetFollow(left Tag) []Tag {}

func getFollowRE(left Tag, depth int) []Tag {}
```

### def pkg

#### json文件结构的对应的结构体 
读取json文件得到`Def`后，需要进行转换才能由程序进行后续操作
```go
type Tag struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

type Def struct {
	Tags        []Tag    `json:"tags"`
	Productions []string `json:"productions"`
}

// InitDef 初始化操作，需在程序的入口处执行，以将json文件的内容读到内存中去
func InitDef() error {}

// GetTags 返回的是程序解析时真正使用的 base.Tag
func GetTags() []base.Tag {}

// GetProductions 返回的是程序解析时使用的 base.Production
// 形如 "E → E+T | E–T | T" 的产生式会被拆分为三个 production
func GetProductions() []base.Production {}
```

#### json文件结构举例
```json
{
  "tags": [
    { "type": "终结符", "value": "+" },
    { "type": "终结符", "value": "-" },
    { "type": "终结符", "value": "*" },
    { "type": "终结符", "value": "/" },
    { "type": "终结符", "value": "(" },
    { "type": "终结符", "value": ")" },
    { "type": "终结符", "value": "num" },
    { "type": "非终结符", "value": "E" },
    { "type": "非终结符", "value": "F" },
    { "type": "非终结符", "value": "T" }
  ],
  "productions": [
    "E → E+T | E-T | T",
    "T → T*F | T/F | F",
    "F → (E) | num"
  ]
}
```

## LL(1)分析程序

### 结构定义

#### 预测分析表

在最外层是一个以非终结符为键的map，其值为一个map，为了便于区分，我们称这个子map为map2，map2的键为终结符，值为产生式，该结构如下：

```go
// LLTable LL(1)预测分析表
type LLTable map[base.Tag]map[base.Tag]base.Production
```

#### 生成分析表 GenerateLLTable

```go
// GenerateLLTable 生成LL(1)预测分析表
func GenerateLLTable() LLTable {}
```

#### 打印分析表

```go
// PrintLLTable 打印LL分析表
func PrintLLTable(table LLTable) error {}
```

#### Tag栈

```go
// TagStack Tag栈，并在最开始放上$和开始符
var TagStack = []base.Tag{
	{Type: base.TERM, Value: "$"},
}

// PopStack 从栈顶弹出一个tag，并返回该tag
func PopStack() base.Tag {}

// PushStack 向栈顶添加一个tag
func PushStack(tag base.Tag) {}
```

#### 分析程序

```go
// LLAnalyze LL分析程序
func LLAnalyze(input string, table LLTable) error {}

// LLAnalyze LL分析程序
func LLAnalyze(input string, table LLTable) error {}
```

### 处理思路

#### 前置条件

1. 无左递归
2. 任意两非终结符的`FIRST`集不相交
3. 如果有可空符号，则其`FOLLOW`集与`FIRST`集不相交

#### 构造预测分析表

1. 对于每一个产生式，如果有形如`A->aB`的形式，则在`a`列添加该产生式
2. 对于首个符号为非终结符的情况，则通过其`FIRST`集填充LL分析表
3. 对于推到空的情况，则在所有左部的`FOLLOW`集中的元素下，加上这个空推导

#### 构造LL(1)分析程序

首先，构造一个`Tag`栈，并在最开始放上`$`和开始符；构造一个输入队列；

函数主体为一个循环，每次循环扫描输入字符串的若干个字符，这若干个字符组成一个Tag；

此时判断`Tag`栈元素，可能有以下两种情况：

1. 栈顶为终结符
   - 如果两者相同，则从栈中弹出该终结符
   - 如果两者不同，则认为分析时出错——输入串不符合该语法；
2. 栈顶为非终结符
   1. 根据LL分析表、栈顶元素与剩余输入串中的首个`Tag`，得到对应生成式
   2. 将生成式反序入栈，进行下一次比对

当输入串中只剩下`$`时，判断`Tag`栈：

- 如果栈中的非终结符与`$`结合都能推出空，则接受输入语句
- 否则，认为输入语句不能接受

## LR(0)分析程序

### 结构定义

### 处理思路

1. 构造拓广文法
   - 程序处理的过程中，认为在`def.json`中的第一个产生式的左部是文法的开始符
   - 如开始符为E，则添加`E'->E`到拓广文法中
2. 

