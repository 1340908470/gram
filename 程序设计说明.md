# 程序设计说明
> 姓名：陈威豪 
> 学号：2019211232 
> 班级：2019211303

## 手工计算例题

### 原表达式

```txt
E → E+T | E–T | T
T → T*F | T/F | F
F → (E) | num
```

### 消除左递归

```txt
E → TE'
E' → +TE' | -TE' | ε
T → FT'
T' → *FT' | /FT' | ε
F → (E) | num
```

## 基本struct及func定义

### base pkg

#### 标识符Tag
```go
type Tag struct {
	// 类型
	Type 	int
	// 值
	Value 	string		
}
```

#### 产生式Production
```go
type Production struct {
	// 当且仅当 Left.Type == NONTERM
	Left Tag
	// 产生式的右部是一个标识符切片
	Right []Tag		
}

// GetProductionsByTag 根据记号，返回该非终结符的所有产生式
func GetProductionsByTag(productions []Production, left Tag) ([]Production, error) {}

// ToString 将产生式转换成字符串
func (p Production) ToString() string {}
```

#### 消除左递归

直接将消除左递归后的产生式集放入堆空间中，替换未消除左递归的产生式集。

```go
// RemoveLeftRecursion 消除左递归
func RemoveLeftRecursion() {
```

#### 检测是否有重复的tag

```go
// HasReTags 是否有重复的tag
func HasReTags(tag Tag, tags []Tag) bool {
```

#### 生成FIRST集
传入一个非终结符，计算该非终结符的`First`集，`getFirstRE`是递归运算函数，处于`GetFirst`下层，不被其他程序调用
```go
// GetFirst 根据推导式的左部，得到其对应的FIRST集
func GetFirst(left Tag) []Tag {}

// GetFirstRE 递归查找First集，并将该次调用得到的tag加到ansTags中
func getFirstRE(symbol Tag, tmpTags []Tag, ansTags *[]Tag) {}
```

#### 生成FOLLOW集
传入一个非终结符，计算该非终结符的`FOLLOW`集，`getFollowRE`是递归运算函数，处于`GetFollow`下层，不被其他程序调用
```go
// GetFollow 根据推导式的左部，得到其对应的Follow集
func GetFollow(left Tag) []Tag {}

func getFollowRE(left Tag, depth int) []Tag {}
```

### def pkg

#### json文件结构的对应的结构体 
读取json文件得到`Def`后，需要进行转换才能由程序进行后续操作
```go
type Tag struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

type Def struct {
	Tags        []Tag    `json:"tags"`
	Productions []string `json:"productions"`
}

// InitDef 初始化操作，需在程序的入口处执行，以将json文件的内容读到内存中去
func InitDef() error {}

// GetTags 返回的是程序解析时真正使用的 base.Tag
func GetTags() []base.Tag {}

// GetProductions 返回的是程序解析时使用的 base.Production
// 形如 "E → E+T | E–T | T" 的产生式会被拆分为三个 production
func GetProductions() []base.Production {}
```

#### json文件结构举例
```json
{
  "tags": [
    { "type": "终结符", "value": "+" },
    { "type": "终结符", "value": "-" },
    { "type": "终结符", "value": "*" },
    { "type": "终结符", "value": "/" },
    { "type": "终结符", "value": "(" },
    { "type": "终结符", "value": ")" },
    { "type": "终结符", "value": "num" },
    { "type": "非终结符", "value": "E" },
    { "type": "非终结符", "value": "F" },
    { "type": "非终结符", "value": "T" }
  ],
  "productions": [
    "E → E+T | E-T | T",
    "T → T*F | T/F | F",
    "F → (E) | num"
  ]
}
```

## LL(1)分析程序

### 结构定义

#### 预测分析表

在最外层是一个以非终结符为键的map，其值为一个map，为了便于区分，我们称这个子map为map2，map2的键为终结符，值为产生式，该结构如下：

```go
// LLTable LL(1)预测分析表
type LLTable map[base.Tag]map[base.Tag]base.Production
```

#### 生成分析表 GenerateLLTable

```go
// GenerateLLTable 生成LL(1)预测分析表
func GenerateLLTable() LLTable {}
```

#### 打印分析表

```go
// PrintLLTable 打印LL分析表
func PrintLLTable(table LLTable) error {}
```

### 处理思路

#### 前置条件

1. 无左递归
2. 任意两非终结符的`FIRST`集不相交
3. 如果有可空符号，则其`FOLLOW`集与`FIRST`集不相交

#### 构造预测分析表

1. 对于每一个产生式，如果有形如`A->aB`的形式，则在a列添加该产生式
2. 对于首个符号为非终结符的情况，则通过其`FIRST`集填充LL分析表

## LR(0)分析程序

### 结构定义



### 处理思路

1. 构造拓广文法
   - 程序处理的过程中，认为在`def.json`中的第一个产生式的左部是文法的开始符
   - 如开始符为E，则添加`E'->E`到拓广文法中
2. 
